
import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import * as nodemailer from "nodemailer";
import { createEvents, type EventAttributes } from 'ics';
import { format, differenceInHours, isAfter, parseISO } from 'date-fns';
import { es } from 'date-fns/locale';

// Initialize Firebase Admin SDK
if (admin.apps.length === 0) {
  admin.initializeApp();
}
const db = admin.firestore();

// --- Interfaces (Align with src/lib/types.ts or define locally) ---
interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

interface Ticket {
  id: string;
  title: string;
  description: string;
  status: string; // 'Abierto', 'En Progreso', 'Resuelto', 'Cerrado'
  priority: string; // 'Alta', 'Media', 'Baja'
  createdAt: admin.firestore.Timestamp;
  updatedAt?: admin.firestore.Timestamp;
  reporterUserId: string;
  assigneeUserId?: string;
  slaId?: string;
  queueId?: string;
  appliedEscalationRuleIds?: string[];
  firstResponseAt?: admin.firestore.Timestamp;
  resolvedAt?: admin.firestore.Timestamp; // Added
  closedAt?: admin.firestore.Timestamp; // Added
  satisfactionSurveySentAt?: admin.firestore.Timestamp; // Added
  satisfactionRating?: number; // Added
  satisfactionComment?: string; // Added
}

interface EscalationRule {
  id: string;
  name: string;
  isEnabled: boolean;
  order: number;
  conditionType: string;
  conditionValue?: string | number;
  actionType: string;
  actionTargetUserId?: string;
  actionTargetPriority?: string;
  actionTargetQueueId?: string;
}

interface SLA {
    id: string;
    name: string;
    responseTimeTargetMinutes: number;
    resolutionTimeTargetHours: number;
    businessHoursOnly: boolean;
}

interface SurveyTemplate {
    id: string;
    name: string;
    type: 'CSAT' | 'NPS' | 'Custom';
    questions: { id: string, text: string, type: string }[]; // Simplified for now
    isEnabled?: boolean;
}

interface SurveyResponse {
    id?: string; // Auto-generated by Firestore
    surveyTemplateId: string;
    ticketId: string;
    reporterUserId: string; // Or contactId/email if applicable
    status: 'pending' | 'completed';
    createdAt: admin.firestore.FieldValue;
    // answers will be stored as a subcollection or map later
}


// --- Existing Email Campaign and Meeting Invitation Code (keep as is) ---
interface EmailCampaign {
  id: string;
  name: string;
  subject: string;
  fromName: string;
  fromEmail: string;
  contactListId: string;
  emailTemplateId: string;
  status: string;
  scheduledAt?: string;
  sentAt?: string;
  createdAt: string;
  updatedAt?: string;
  analytics: {
    totalRecipients: number;
    emailsSent: number;
  };
}

interface Contact {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  subscribed?: boolean;
}

interface EmailTemplate {
  id: string;
  name: string;
  subject: string;
  contentHtml?: string;
}

interface MeetingAttendee {
  id: string;
  type: 'user' | 'contact' | 'external';
  name: string;
  email: string;
  status: 'Aceptada' | 'Rechazada' | 'Pendiente' | 'Tentativa';
}

interface Meeting {
  id: string;
  title: string;
  description?: string;
  startTime: string; // ISO string
  endTime: string; // ISO string
  attendees: MeetingAttendee[];
  location?: string;
  conferenceLink?: string;
  createdByUserId: string;
  status: 'Programada' | 'Confirmada' | 'Cancelada' | 'Realizada' | 'Pospuesta';
}


let mailTransport: nodemailer.Transporter | null = null;
let defaultSenderEmail = "noreply@example.com";
let defaultSenderName = "MiniCRM Express";

async function getMailTransport(forceRefresh: boolean = false) {
  if (mailTransport && !forceRefresh) {
    return mailTransport;
  }
  try {
    const settingsDoc = await db.collection("settings").doc("emailConfiguration").get();
    if (!settingsDoc.exists) {
      functions.logger.error("Configuración de correo electrónico no encontrada en Firestore.");
      throw new Error("Email settings not found.");
    }
    const settings = settingsDoc.data();
    if (!settings || !settings.smtpHost || !settings.smtpPort || !settings.smtpUser || !settings.smtpPass) {
      functions.logger.error("Configuración SMTP incompleta en Firestore.", settings);
      throw new Error("Incomplete SMTP settings.");
    }

    defaultSenderEmail = settings.defaultSenderEmail || "noreply@example.com";
    defaultSenderName = settings.defaultSenderName || "MiniCRM Express";

    mailTransport = nodemailer.createTransport({
      host: settings.smtpHost,
      port: parseInt(settings.smtpPort as string || "587"),
      secure: settings.smtpSecurity === "SSL" || settings.smtpSecurity === "TLS",
      auth: {
        user: settings.smtpUser,
        pass: settings.smtpPass,
      },
      ...(settings.smtpSecurity === "TLS" && {
          tls: {
              rejectUnauthorized: process.env.NODE_ENV === "production",
          },
      }),
    });
    functions.logger.info("Mail transporter configurado exitosamente desde Firestore.");
    return mailTransport;
  } catch (error) {
    functions.logger.error("Error al configurar el mail transporter desde Firestore:", error);
    mailTransport = null;
    throw error;
  }
}

function personalizeContent(content: string, contact: Contact, campaignFromName: string): string {
  let personalized = content;
  personalized = personalized.replace(/{{nombre_contacto}}/g, `${contact.firstName || ""} ${contact.lastName || ""}`.trim() || contact.email);
  personalized = personalized.replace(/{{email_contacto}}/g, contact.email);
  personalized = personalized.replace(/{{nombre_empresa_remitente}}/g, campaignFromName || defaultSenderName);
  return personalized;
}

export const sendEmailCampaign = functions.region('southamerica-west1').firestore
  .document("emailCampaigns/{campaignId}")
  .onUpdate(async (change, context) => {
    const campaignId = context.params.campaignId;
    const newData = change.after.data() as EmailCampaign;
    const oldData = change.before.data() as EmailCampaign;

    if (newData.status !== "Enviando") {
      functions.logger.info(`Campaign ${campaignId}: Status is not 'Enviando'. Current status: ${newData.status}. Skipping.`);
      return null;
    }
    if (oldData.status === "Enviando" && newData.updatedAt === oldData.updatedAt && (newData.analytics?.emailsSent || 0) > 0) {
        functions.logger.info(`Campaign ${campaignId}: Already processed or no relevant update. Skipping.`);
        return null;
    }

    functions.logger.info(`Campaign ${campaignId}: Processing campaign in 'Enviando' state.`);

    try {
      const transporter = await getMailTransport(true);
      const contactListDoc = await db.collection("contactLists").doc(newData.contactListId).get();
      if (!contactListDoc.exists) throw new Error(`Contact list ${newData.contactListId} not found.`);
      
      const contactsSnapshot = await db.collection("contacts").where("listIds", "array-contains", newData.contactListId).get();
      const contactsData: Contact[] = contactsSnapshot.docs
        .map((doc) => ({id: doc.id, ...doc.data()} as Contact))
        .filter(contact => contact.subscribed !== false);

      const totalRecipients = contactsData.length;
      await db.collection("emailCampaigns").doc(campaignId).set({
        analytics: { ...newData.analytics, totalRecipients: totalRecipients, emailsSent: 0 }
      }, { merge: true });

      if (totalRecipients === 0) {
        functions.logger.info(`Campaign ${campaignId}: No subscribed contacts. Marking as sent.`);
        await db.collection("emailCampaigns").doc(campaignId).update({
          status: "Enviada",
          sentAt: admin.firestore.FieldValue.serverTimestamp(),
          "analytics.totalRecipients": 0,
          "analytics.emailsSent": 0,
        });
        return null;
      }

      const templateDoc = await db.collection("emailTemplates").doc(newData.emailTemplateId).get();
      if (!templateDoc.exists) throw new Error(`Email template ${newData.emailTemplateId} not found.`);
      const template = templateDoc.data() as EmailTemplate;

      let emailsSuccessfullySent = 0;
      const emailPromises = contactsData.map(async (contact) => {
        if (!contact.email) {
          functions.logger.warn(`Campaign ${campaignId}: Skipping contact ${contact.id} (missing email).`);
          return;
        }
        const personalizedHtml = personalizeContent(template.contentHtml || "", contact, newData.fromName);
        const mailOptions = {
          from: `"${newData.fromName || defaultSenderName}" <${newData.fromEmail || defaultSenderEmail}>`,
          to: contact.email,
          subject: newData.subject,
          html: personalizedHtml,
        };
        try {
          await transporter.sendMail(mailOptions);
          emailsSuccessfullySent++;
          functions.logger.info(`Campaign ${campaignId}: Email sent to ${contact.email}`);
        } catch (error) {
          functions.logger.error(`Campaign ${campaignId}: Failed to send to ${contact.email}`, error);
        }
      });

      await Promise.all(emailPromises);

      functions.logger.info(`Campaign ${campaignId}: Finished sending. ${emailsSuccessfullySent}/${totalRecipients} emails sent successfully.`);
      const finalStatus = emailsSuccessfullySent > 0 || totalRecipients === 0 ? "Enviada" : "Fallida";
      await db.collection("emailCampaigns").doc(campaignId).update({
        status: finalStatus,
        sentAt: admin.firestore.FieldValue.serverTimestamp(),
        "analytics.emailsSent": emailsSuccessfullySent,
      });

      return null;
    } catch (error) {
      functions.logger.error(`Campaign ${campaignId}: Error processing campaign:`, error);
      try {
        await db.collection("emailCampaigns").doc(campaignId).update({
            status: "Fallida",
            "analytics.totalRecipients": newData.analytics?.totalRecipients || 0,
            "analytics.emailsSent": newData.analytics?.emailsSent || 0,
        });
      } catch (updateError) {
          functions.logger.error(`Campaign ${campaignId}: Error updating campaign to Fallida status:`, updateError);
      }
      return null;
    }
  });

export const sendMeetingInvitation = functions.region('southamerica-west1').firestore
  .document('meetings/{meetingId}')
  .onWrite(async (change, context) => {
    const meetingId = context.params.meetingId;
    const meetingData = change.after.exists ? change.after.data() as Meeting : null;
    const oldMeetingData = change.before.exists ? change.before.data() as Meeting : null;

    if (!meetingData) {
      functions.logger.info(`Meeting ${meetingId} deleted. No action taken.`);
      return null;
    }

    const isNewMeeting = !change.before.exists;
    const attendeesChanged = oldMeetingData ? JSON.stringify(oldMeetingData.attendees.map(a => ({email:a.email, status:a.status})).sort()) !== JSON.stringify(meetingData.attendees.map(a => ({email:a.email, status:a.status})).sort()) : false;
    const timeChanged = oldMeetingData ? (oldMeetingData.startTime !== meetingData.startTime || oldMeetingData.endTime !== meetingData.endTime) : false;
    const statusChanged = oldMeetingData ? oldMeetingData.status !== meetingData.status : false;
    
    let shouldSend = isNewMeeting || attendeesChanged || timeChanged || (statusChanged && meetingData.status === 'Confirmada');
    
    if (meetingData.status === 'Cancelada' || meetingData.status === 'Realizada') {
        if (isNewMeeting || (statusChanged && oldMeetingData?.status !== meetingData.status)){
            functions.logger.info(`Meeting ${meetingId} status is ${meetingData.status}. Sending update/cancellation.`);
        } else {
             functions.logger.info(`Meeting ${meetingId} status is ${meetingData.status}. No critical changes for resend.`);
             shouldSend = false;
        }
    }
    
    if (!shouldSend) {
      functions.logger.info(`Meeting ${meetingId}: No conditions met for sending/resending invitations. Skipping.`);
      return null;
    }

    functions.logger.info(`Processing meeting ${meetingId} for invitations. Status: ${meetingData.status}`);

    try {
      const transporter = await getMailTransport(true);
      const creatorUserDoc = await db.collection('users').doc(meetingData.createdByUserId).get();
      const creatorUser = creatorUserDoc.exists ? creatorUserDoc.data() as {name: string, email: string} : null;

      const organizerName = creatorUser?.name || defaultSenderName;
      const organizerEmail = creatorUser?.email || defaultSenderEmail;

      const start = new Date(meetingData.startTime);
      const end = new Date(meetingData.endTime);
      const durationMillis = end.getTime() - start.getTime();
      const durationHours = Math.floor(durationMillis / (1000 * 60 * 60));
      const durationMinutes = Math.floor((durationMillis % (1000 * 60 * 60)) / (1000 * 60));

      const event: EventAttributes = {
        start: [start.getUTCFullYear(), start.getUTCMonth() + 1, start.getUTCDate(), start.getUTCHours(), start.getUTCMinutes()],
        duration: { hours: durationHours, minutes: durationMinutes },
        title: meetingData.title,
        description: meetingData.description || '',
        location: meetingData.location || '',
        url: meetingData.conferenceLink || '',
        status: meetingData.status === 'Cancelada' ? 'CANCELLED' : (meetingData.status === 'Confirmada' || meetingData.status === 'Realizada' ? 'CONFIRMED' : 'TENTATIVE'),
        organizer: { name: organizerName, email: organizerEmail },
        attendees: meetingData.attendees.map(att => ({
          name: att.name,
          email: att.email,
          rsvp: att.status === 'Aceptada',
          partstat: att.status === 'Aceptada' ? 'ACCEPTED' : att.status === 'Rechazada' ? 'DECLINED' : att.status === 'Tentativa' ? 'TENTATIVE' : 'NEEDS-ACTION',
          role: 'REQ-PARTICIPANT'
        }))
      };

      const { error: icsError, value: icsFileContent } = createEvents([event]);
      if (icsError || !icsFileContent) {
        functions.logger.error(`Error creating .ics file for meeting ${meetingId}:`, icsError);
        throw new Error("Could not generate .ics file.");
      }

      const emailPromises = meetingData.attendees.map(async (attendee) => {
        const oldAttendeeData = oldMeetingData?.attendees.find(a => a.email === attendee.email);
        const attendeeStatusChanged = oldAttendeeData ? oldAttendeeData.status !== attendee.status : false;
        
        if (isNewMeeting || timeChanged || statusChanged || !oldAttendeeData || attendeeStatusChanged) {
            const subjectPrefix = meetingData.status === 'Cancelada' ? 'Cancelación: ' : (isNewMeeting || !oldMeetingData ? 'Invitación: ' : 'Actualización: ');
            const mailOptions: nodemailer.SendMailOptions = {
            from: `"${organizerName}" <${organizerEmail}>`,
            to: attendee.email,
            subject: `${subjectPrefix}${meetingData.title}`,
            html: `
                <p>Hola ${attendee.name},</p>
                <p>Estás ${meetingData.status === 'Cancelada' ? 'notificado/a de la cancelación de' : 'invitado/a a'} la reunión: <strong>${meetingData.title}</strong>.</p>
                ${meetingData.description ? `<p>Detalles: ${meetingData.description}</p>` : ''}
                <p><strong>Cuándo:</strong> ${start.toLocaleString('es-ES', { timeZone: 'UTC' })} - ${end.toLocaleString('es-ES', { timeZone: 'UTC' })} (UTC)</p>
                ${meetingData.location ? `<p><strong>Dónde:</strong> ${meetingData.location}</p>` : ''}
                ${meetingData.conferenceLink ? `<p><strong>Enlace:</strong> <a href="${meetingData.conferenceLink}">${meetingData.conferenceLink}</a></p>` : ''}
                <p>Por favor, añade este evento a tu calendario.</p>
                <p>Saludos,<br/>${organizerName}</p>
            `,
            icalEvent: {
                filename: 'invite.ics',
                method: meetingData.status === 'Cancelada' ? 'CANCEL' : 'REQUEST',
                content: icsFileContent
            }
            };

            try {
            await transporter.sendMail(mailOptions);
            functions.logger.info(`Meeting ${meetingId}: Invitation/Update sent to ${attendee.email}`);
            } catch (sendError) {
            functions.logger.error(`Meeting ${meetingId}: Failed to send invitation/update to ${attendee.email}`, sendError);
            }
        } else {
             functions.logger.info(`Meeting ${meetingId}: No change requiring re-invite for attendee ${attendee.email}`);
        }
      });

      await Promise.all(emailPromises);
      functions.logger.info(`Meeting ${meetingId}: Finished sending invitations/updates.`);
      return null;
    } catch (error) {
      functions.logger.error(`Meeting ${meetingId}: Error processing invitations:`, error);
      return null;
    }
  });

// --- Escalation Rule Functions ---
async function sendNotificationEmail(recipientEmail: string, subject: string, htmlBody: string) {
  if (!recipientEmail) {
    functions.logger.warn("No recipient email provided for notification.");
    return;
  }
  try {
    const transporter = await getMailTransport();
    const mailOptions = {
      from: `"${defaultSenderName} - Alertas CRM" <${defaultSenderEmail}>`,
      to: recipientEmail,
      subject: subject,
      html: htmlBody,
    };
    await transporter.sendMail(mailOptions);
    functions.logger.info(`Notification email sent to ${recipientEmail} with subject: ${subject}`);
  } catch (error) {
    functions.logger.error(`Failed to send notification email to ${recipientEmail}:`, error);
  }
}

async function logEscalationEvent(
  ticketId: string,
  ruleId: string,
  ruleName: string,
  conditionMet: string,
  actionTaken: string,
  details?: string
) {
  try {
    await db.collection("escalationLogs").add({
      ticketId,
      ruleId,
      ruleName,
      conditionMet,
      actionTaken,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      details: details || "",
    });
    functions.logger.info(`Escalation logged for ticket ${ticketId}, rule ${ruleName}.`);
  } catch (error) {
    functions.logger.error("Error logging escalation event:", error);
  }
}

export const evaluateEscalationRules = functions.region('southamerica-west1')
  .pubsub.schedule("every 10 minutes")
  .onRun(async (context) => {
    functions.logger.info("Starting escalation rule evaluation...");

    try {
      const rulesSnapshot = await db.collection("escalationRules")
        .where("isEnabled", "==", true)
        .orderBy("order", "asc")
        .get();
      
      if (rulesSnapshot.empty) {
        functions.logger.info("No active escalation rules found.");
        return null;
      }
      const rules = rulesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as EscalationRule));

      const activeTicketStatuses = ["Abierto", "En Progreso"];
      const ticketsSnapshot = await db.collection("tickets")
        .where("status", "in", activeTicketStatuses)
        .get();

      if (ticketsSnapshot.empty) {
        functions.logger.info("No active tickets found to evaluate.");
        return null;
      }
      const tickets = ticketsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Ticket));
      
      const now = new Date();

      for (const ticket of tickets) {
        functions.logger.info(`Evaluating ticket ${ticket.id} (${ticket.title})`);
        const ticketRef = db.collection("tickets").doc(ticket.id);
        let ticketSLA: SLA | null = null;
        if (ticket.slaId) {
            const slaDoc = await db.collection("slas").doc(ticket.slaId).get();
            if (slaDoc.exists) ticketSLA = slaDoc.data() as SLA;
        }

        for (const rule of rules) {
          if (ticket.appliedEscalationRuleIds?.includes(rule.id)) {
            continue;
          }

          let conditionMet = false;
          let conditionDescription = "";

          switch (rule.conditionType) {
            case "sla_response_breached":
              if (ticketSLA && ticket.status === "Abierto" && !ticket.firstResponseAt) {
                  const createdAtDate = ticket.createdAt.toDate();
                  const expectedResponseTime = new Date(createdAtDate.getTime() + ticketSLA.responseTimeTargetMinutes * 60000);
                  if (isAfter(now, expectedResponseTime)) {
                      conditionMet = true;
                      conditionDescription = `SLA de respuesta (${ticketSLA.responseTimeTargetMinutes} min) incumplido.`;
                  }
              }
              break;
            case "sla_resolution_breached":
              if (ticketSLA && ticket.status !== "Resuelto" && ticket.status !== "Cerrado") {
                  const createdAtDate = ticket.createdAt.toDate();
                  const expectedResolutionTime = new Date(createdAtDate.getTime() + ticketSLA.resolutionTimeTargetHours * 60 * 60000);
                  if (isAfter(now, expectedResolutionTime)) {
                      conditionMet = true;
                      conditionDescription = `SLA de resolución (${ticketSLA.resolutionTimeTargetHours} hrs) incumplido.`;
                  }
              }
              break;
            case "ticket_idle_for_x_hours":
              const idleHours = typeof rule.conditionValue === 'number' ? rule.conditionValue : parseInt(String(rule.conditionValue), 10);
              if (!isNaN(idleHours) && ticket.updatedAt) {
                const updatedAtDate = ticket.updatedAt.toDate();
                if (differenceInHours(now, updatedAtDate) > idleHours) {
                  conditionMet = true;
                  conditionDescription = `Ticket inactivo por más de ${idleHours} horas.`;
                }
              } else if (!isNaN(idleHours) && !ticket.updatedAt) {
                 const createdAtDate = ticket.createdAt.toDate();
                 if (differenceInHours(now, createdAtDate) > idleHours) {
                  conditionMet = true;
                  conditionDescription = `Ticket inactivo (basado en creación) por más de ${idleHours} horas.`;
                }
              }
              break;
            case "ticket_priority_is":
              if (ticket.priority === rule.conditionValue) {
                conditionMet = true;
                conditionDescription = `Prioridad del ticket es '${rule.conditionValue}'.`;
              }
              break;
            case "ticket_in_queue":
              if (ticket.queueId === rule.conditionValue) {
                conditionMet = true;
                conditionDescription = `Ticket está en la cola ID '${rule.conditionValue}'.`;
              }
              break;
          }

          if (conditionMet) {
            functions.logger.info(`Rule '${rule.name}' condition met for ticket ${ticket.id}: ${conditionDescription}`);
            let actionDescription = "";
            const updateData: Partial<Ticket> & { updatedAt: admin.firestore.FieldValue } = { updatedAt: admin.firestore.FieldValue.serverTimestamp() as admin.firestore.Timestamp };
            
            switch (rule.actionType) {
              case "notify_user":
                if (rule.actionTargetUserId) {
                  const userDoc = await db.collection("users").doc(rule.actionTargetUserId).get();
                  if (userDoc.exists) {
                    const userToNotify = userDoc.data() as User;
                    const subject = `Alerta de Escalado CRM: Ticket #${ticket.id} - ${ticket.title}`;
                    const body = `
                      <p>Hola ${userToNotify.name},</p>
                      <p>El ticket <strong>#${ticket.id} (${ticket.title})</strong> ha sido escalado debido a la regla: "${rule.name}".</p>
                      <p>Condición cumplida: ${conditionDescription}</p>
                      <p>Por favor, revisa el ticket en el CRM.</p>
                      <p>Gracias,<br/>Sistema CRM Rápido</p>
                    `;
                    await sendNotificationEmail(userToNotify.email, subject, body);
                    actionDescription = `Notificado al usuario: ${userToNotify.name} (${userToNotify.email})`;
                  } else {
                     actionDescription = `Usuario objetivo ${rule.actionTargetUserId} para notificación no encontrado.`;
                     functions.logger.warn(actionDescription);
                  }
                }
                break;
              case "change_priority":
                if (rule.actionTargetPriority) {
                  updateData.priority = rule.actionTargetPriority;
                  actionDescription = `Prioridad cambiada a: ${rule.actionTargetPriority}`;
                }
                break;
              case "assign_to_user":
                if (rule.actionTargetUserId) {
                  updateData.assigneeUserId = rule.actionTargetUserId;
                  const userDoc = await db.collection("users").doc(rule.actionTargetUserId).get();
                  const userName = userDoc.exists ? (userDoc.data() as User).name : rule.actionTargetUserId;
                  actionDescription = `Asignado al usuario: ${userName}`;
                }
                break;
               case "assign_to_queue":
                if (rule.actionTargetQueueId) {
                  updateData.queueId = rule.actionTargetQueueId;
                  actionDescription = `Movido a la cola ID: ${rule.actionTargetQueueId}`;
                }
                break;
            }
            
            updateData.appliedEscalationRuleIds = admin.firestore.FieldValue.arrayUnion(rule.id) as any;

            if (Object.keys(updateData).length > 1) {
                await ticketRef.update(updateData);
                functions.logger.info(`Ticket ${ticket.id} actualizado por regla ${rule.name}. Acción: ${actionDescription}`);
            } else {
                 functions.logger.info(`Solo se ejecutó una notificación para la regla ${rule.name} en el ticket ${ticket.id}, no se requieren cambios en el ticket más allá de marcar la regla como aplicada.`);
                 await ticketRef.update({ appliedEscalationRuleIds: admin.firestore.FieldValue.arrayUnion(rule.id) });
            }

            await logEscalationEvent(ticket.id, rule.id, rule.name, conditionDescription, actionDescription);
            break;
          }
        }
      }
      functions.logger.info("Escalation rule evaluation finished.");
      return null;
    } catch (error) {
      functions.logger.error("Error evaluating escalation rules:", error);
      return null;
    }
  });

// --- Satisfaction Survey Function ---
export const sendSatisfactionSurvey = functions.region('southamerica-west1').firestore
  .document("tickets/{ticketId}")
  .onUpdate(async (change, context) => {
    const ticketId = context.params.ticketId;
    const newData = change.after.data() as Ticket;
    const oldData = change.before.data() as Ticket;

    const shouldSendSurvey = (newData.status === 'Resuelto' || newData.status === 'Cerrado') &&
                             (oldData.status !== 'Resuelto' && oldData.status !== 'Cerrado') &&
                             !newData.satisfactionSurveySentAt;

    if (!shouldSendSurvey) {
      functions.logger.info(`Ticket ${ticketId}: Conditions not met for sending survey. Status: ${newData.status}, Already sent: ${!!newData.satisfactionSurveySentAt}`);
      return null;
    }

    functions.logger.info(`Ticket ${ticketId}: Conditions met. Preparing to send satisfaction survey.`);

    try {
      // 1. Get Reporter's Email
      const reporterUserDoc = await db.collection("users").doc(newData.reporterUserId).get();
      if (!reporterUserDoc.exists || !reporterUserDoc.data()?.email) {
        functions.logger.error(`Ticket ${ticketId}: Reporter user ${newData.reporterUserId} or their email not found.`);
        // Optionally update ticket to indicate survey could not be sent
        await db.collection("tickets").doc(ticketId).update({ satisfactionSurveySentAt: admin.firestore.FieldValue.serverTimestamp(), satisfactionComment: "Error: Email de destinatario no encontrado." });
        return null;
      }
      const reporterEmail = reporterUserDoc.data()?.email;
      const reporterName = reporterUserDoc.data()?.name || "Cliente";

      // 2. Get a CSAT Survey Template
      const templateQuery = await db.collection("surveyTemplates")
        .where("type", "==", "CSAT")
        .where("isEnabled", "==", true)
        .limit(1)
        .get();

      if (templateQuery.empty) {
        functions.logger.error(`Ticket ${ticketId}: No active CSAT survey template found.`);
        await db.collection("tickets").doc(ticketId).update({ satisfactionSurveySentAt: admin.firestore.FieldValue.serverTimestamp(), satisfactionComment: "Error: Plantilla de encuesta no encontrada." });
        return null;
      }
      const surveyTemplate = templateQuery.docs[0].data() as SurveyTemplate;
      const surveyTemplateId = templateQuery.docs[0].id;

      // 3. Create a Survey Response Document
      const surveyResponseRef = db.collection("surveyResponses").doc(); // Auto-generate ID
      const newSurveyResponse: SurveyResponse = {
        surveyTemplateId: surveyTemplateId,
        ticketId: ticketId,
        reporterUserId: newData.reporterUserId,
        status: 'pending',
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      };
      await surveyResponseRef.set(newSurveyResponse);
      const surveyResponseId = surveyResponseRef.id;

      // 4. Construct Survey Link
      const appPublicUrl = functions.config().app?.public_url || "https://your-app-domain.com"; // Fallback if not set
      if (appPublicUrl === "https://your-app-domain.com") {
         functions.logger.warn("La variable de entorno app.public_url no está configurada. Usando URL de placeholder.");
      }
      const surveyLink = `${appPublicUrl}/survey/${surveyResponseId}`;

      // 5. Compose Email
      const emailSubject = `Valoramos tu opinión sobre el ticket: ${newData.title}`;
      const emailBody = `
        <p>Hola ${reporterName},</p>
        <p>Hemos resuelto tu ticket de soporte: "${newData.title}".</p>
        <p>Nos gustaría conocer tu opinión sobre la atención recibida. Por favor, tómate un momento para completar nuestra breve encuesta de satisfacción:</p>
        <p><a href="${surveyLink}" style="padding: 10px 15px; background-color: #29ABE2; color: white; text-decoration: none; border-radius: 5px;">Completar Encuesta</a></p>
        <p>Tu feedback es muy importante para nosotros.</p>
        <p>Gracias,<br/>El equipo de ${defaultSenderName}</p>
      `;

      // 6. Send Email
      const transporter = await getMailTransport();
      await transporter.sendMail({
        from: `"${defaultSenderName}" <${defaultSenderEmail}>`,
        to: reporterEmail,
        subject: emailSubject,
        html: emailBody,
      });

      functions.logger.info(`Ticket ${ticketId}: Satisfaction survey email sent to ${reporterEmail}. Response ID: ${surveyResponseId}`);

      // 7. Update Ticket
      await db.collection("tickets").doc(ticketId).update({
        satisfactionSurveySentAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return null;
    } catch (error) {
      functions.logger.error(`Ticket ${ticketId}: Error sending satisfaction survey:`, error);
      try {
        // Attempt to mark that sending failed to prevent retries for this specific error
        await db.collection("tickets").doc(ticketId).update({
             satisfactionSurveySentAt: admin.firestore.FieldValue.serverTimestamp(), // Still mark as attempt
             satisfactionComment: `Error al enviar encuesta: ${String(error).substring(0,100)}`
        });
      } catch (updateError) {
          functions.logger.error(`Ticket ${ticketId}: Error updating ticket after survey send failure:`, updateError);
      }
      return null;
    }
  });

        
